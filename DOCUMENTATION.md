# Документация по проекту WebRTC P2P Phone

Этот документ представляет собой всеобъемлющий обзор приложения WebRTC P2P Phone, включая его архитектуру, детали реализации бэкенда и фронтенда, а также инструкции по установке.

## 1. Обзор проекта

WebRTC P2P Phone — это веб-приложение, которое позволяет пользователям совершать peer-to-peer аудио/видео звонки с использованием стандарта WebRTC. В приложении реализованы регистрация и аутентификация пользователей, отображение списка онлайн-пользователей и интерфейс для звонков в реальном времени. Обмен сигнальными сообщениями для установки соединения WebRTC происходит через WebSocket.

## 2. Архитектура

Приложение использует классическую клиент-серверную архитектуру, состоящую из трех основных частей:

*   **Фронтенд:** Одностраничное приложение (SPA), созданное с помощью React и TypeScript, которое предоставляет пользовательский интерфейс.
*   **Бэкенд:** Приложение на Java Spring Boot, которое обслуживает фронтенд, обрабатывает аутентификацию пользователей и предоставляет WebSocket-сервер для сигнализации WebRTC.
*   **Nginx:** Используется в качестве обратного прокси в продакшн-окружении Docker для обработки HTTPS и маршрутизации трафика на бэкенд.

### Архитектурная диаграмма (концептуальная)

```
  Браузер пользователя (Фронтенд)
        |
        | (HTTPS: веб-приложение, API-запросы, WebSocket)
        v
+-----------------+
|      Nginx      | (Обратный прокси, SSL-терминация)
+-----------------+
        |
        | (HTTP/WebSocket)
        v
+-----------------+
| Бэкенд (Spring)|
| - REST API      |
| - WebSocket     |
+-----------------+
```

## 3. Бэкенд (Java / Spring Boot)

Бэкенд отвечает за управление пользователями, аутентификацию и сигнализацию WebRTC.

*   **Фреймворк:** Spring Boot
*   **Аутентификация:** Spring Security с использованием JSON Web Tokens (JWT)
*   **Обмен данными в реальном времени:** Spring WebSocket
*   **Система сборки:** Maven

### Ключевые пакеты и классы:

*   **`configs`**:
    *   `SecurityConfig.java`: Настраивает Spring Security, включая публичные (`/auth/**`) и защищенные маршруты.
    *   `WebSocketConfig.java`: Настраивает конечную точку WebSocket и обработчики.
    *   `JwtAuthHandshakeInterceptor.java`: Перехватывает запросы на установление WebSocket-соединения для аутентификации пользователей по JWT-токену из параметров запроса.
*   **`controllers`**:
    *   `AuthController.java`: Обрабатывает регистрацию и вход пользователей, выпуская JWT при успешной аутентификации.
    *   `SocketHandler.java`: Ядро логики сигнализации. Управляет сессиями WebSocket, обрабатывает входящие сигнальные сообщения (предложения, ответы, ICE-кандидаты) и пересылает их соответствующему пиру.
*   **`models`**:
    *   `User.java`: Сущность JPA, представляющая пользователя в базе данных.
    *   `LoginRequest.java`, `RegisterRequest.java`: Объекты передачи данных (DTO) для запросов аутентификации.
*   **`repositories`**:
    *   `UserRepository.java`: Репозиторий Spring Data JPA для операций с сущностью `User` в базе данных.
*   **`services`**:
    *   `JwtService.java`: Предоставляет утилиты для генерации и проверки JWT.
    *   `UserRegistration.java`: Содержит бизнес-логику для регистрации нового пользователя.
    *   `MailServices.java`: (Вероятно, для функций типа подтверждения по электронной почте, судя по названиям файлов, не реализовано полностью).

### Процесс аутентификации

1.  Пользователь регистрируется или входит в систему через REST-эндпоинты `/auth/register` или `/auth/login`.
2.  В случае успеха `AuthController` возвращает JWT.
3.  Фронтенд сохраняет этот JWT и включает его в последующие запросы.
4.  Для установки WebSocket-соединения фронтенд подключается к эндпоинту `/ws`, передавая JWT в качестве параметра запроса.
5.  `JwtAuthHandshakeInterceptor` проверяет токен перед установлением соединения.

### Сигнализация через WebSocket

Класс `SocketHandler` управляет процессом сигнализации. При подключении пользователь добавляется в карту сессий. Когда один пользователь хочет позвонить другому, фронтенд отправляет сигнальные сообщения (offers, answers, ICE candidates) через WebSocket. `SocketHandler` находит сессию получателя и пересылает ему сообщение.

## 4. Фронтенд (React / TypeScript)

Фронтенд — это современное SPA, обеспечивающее реактивный и отзывчивый пользовательский интерфейс.

*   **Фреймворк:** React
*   **Язык:** TypeScript
*   **Сборщик:** Vite
*   **Стилизация:** обычный CSS

### Структура проекта:

*   **`components`**: Переиспользуемые компоненты пользовательского интерфейса.
    *   `Auth.tsx`: Компонент-обертка для защищенных маршрутов, гарантирующий доступ только для аутентифицированных пользователей.
    *   `CallControls.tsx`: Пользовательский интерфейс для управления звонком (например, выключить микрофон, повесить трубку).
    *   `Header.tsx`: Основной заголовок приложения.
    *   `VideoPlayer.tsx`: Компонент для отображения локального и удаленного видеопотоков.
*   **`contexts`**: React Context для глобального управления состоянием.
    *   `AuthProvider.tsx`: Управляет состоянием аутентификации пользователя (данные пользователя, JWT-токен).
    *   `SocketProvider.tsx`: Управляет WebSocket-соединением и предоставляет его остальным частям приложения.
*   **`hooks`**: Пользовательские хуки для инкапсуляции сложной логики.
    *   `useAuth.ts`: Предоставляет легкий доступ к контексту аутентификации (например, `login`, `logout`, `user`).
    *   `useSocket.ts`: Предоставляет легкий доступ к контексту WebSocket.
    *   `useWebRTC.ts`: Ядро логики WebRTC на фронтенде. Он обрабатывает создание объектов `RTCPeerConnection`, управляет медиапотоками и взаимодействует с сигнальным сервером через `SocketProvider`.
*   **`pages`**: Компоненты верхнего уровня для различных маршрутов приложения.
    *   `HomePage.tsx`: Основная страница после входа, вероятно, отображающая список онлайн-пользователей и интерфейс звонков.
    *   `LoginPage.tsx`: Форма входа.
    *   `RegisterPage.tsx`: Форма регистрации.
*   **`services`**: (Вероятно, содержит вызовы API к бэкенду).

### Логика WebRTC

Хук `useWebRTC.ts` является центральным элементом функциональности звонков. Он, скорее всего, выполняет следующие шаги:
1.  Получает локальный медиапоток пользователя (`getUserMedia`).
2.  Создает `RTCPeerConnection`.
3.  Добавляет треки локального медиапотока в соединение.
4.  Использует `SocketContext` для отправки сигнальных сообщений (создание и отправка предложений).
5.  Прослушивает входящие сигнальные сообщения от удаленного пира (предложения, ответы) и применяет их к `RTCPeerConnection`.
6.  Обрабатывает ICE-кандидатов, отправляя их пиру через WebSocket для установления P2P-соединения.
7.  Управляет удаленным медиапотоком, когда он становится доступным.

## 5. Установка и запуск проекта

Проект контейнеризирован с помощью Docker и может быть легко запущен с помощью Docker Compose.

### Продакшн-окружение

Для запуска приложения в окружении, приближенном к продакшн (с Nginx для HTTPS):

```bash
docker-compose -f docker-compose.prod.yml up --build
```

Эта команда:
1.  Соберет бэкенд-приложение на Java.
2.  Соберет фронтенд-приложение на React.
3.  Создаст Docker-образы для бэкенда, фронтенда (обслуживаемого через Nginx) и базы данных.
4.  Запустит все сервисы.

Приложение будет доступно по адресу `https://localhost`.

### Окружение для разработки

Для разработки вы можете использовать стандартный `docker-compose.yml`:

```bash
docker-compose up --build
```

Этот вариант, скорее всего, использует сервер для разработки фронтенда с горячей перезагрузкой и предоставляет прямой доступ к API бэкенда.
